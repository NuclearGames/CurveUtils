@page "/curveseditor"
@layout FullWindowLayout
@implements IDisposable

@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D
@using Curves
@using CurvesWebEditor.Data.CanvasRendering
@using CurvesWebEditor.Data.CurvesEditor
@using System.IO
@using System.Text
@inject IJSRuntime JsRuntime;

<PageTitle>Curves Editor</PageTitle>

<div style="background-color:orange; border-right:2px; position: fixed; width: 200px; height: 100%;">
    <div style="position: fixed; width:180px; left:10px;">
        <NavLink class="nav-link" href="/">
            <span class="oi oi-list-rich" aria-hidden="true"></span> Выйти
        </NavLink>

        <br />
        <hr />
        <label>Множители для осей</label>
        <label for="xAspect">Множитель X</label>
        <input id="xAspect" style="width:100%" @bind="_axisAspects.XString"></input>
        <br />
        <label for="yAspect">Множитель Y</label>
        <input id="yAspect" style="width:100%" @bind="_axisAspects.YString"></input>
        <br />
        <hr />

        <button @onclick="DownloadResults">Скачать</button>
    </div>
</div>

<div id="canvasViewport" style="background-color:black; position: fixed; width: calc(100% - 200px); height: 100%; left:200px;">
    <BECanvas Width="600" Height="400" @ref="_canvasReference"></BECanvas>
</div>


@code {
    private const int LEFT_PANEL_WIDTH = 200;
    private BECanvasComponent? _canvasReference;
    private Canvas2DContext? _canvasContext;
    private CanvasRender? _render;
    private float _time = 0f;
    private int _viewportWidth, _viewportHeight;
    private bool _disposed;

    private AxisAspectValues _axisAspects = new AxisAspectValues(1f, 1f);

    private bool HandleJsEvents => !_disposed && _render != null;

    protected async override Task OnAfterRenderAsync(bool firstRender) {
        if(firstRender) {
            _canvasContext = await _canvasReference.CreateCanvas2DAsync();
            await JsRuntime.InvokeAsync<object>("canvasInit", DotNetObjectReference.Create(this));
            _render = new CanvasRender(_canvasContext, _viewportWidth, _viewportHeight);
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    [JSInvokable]
    public void CanvasResize(int width, int height) {
        if (_disposed) {
            return;
        }

        _viewportWidth = width;
        _viewportHeight = height;

        if (_render != null) {
            _render.Resize(width, height);
        }
    }

    [JSInvokable]
    public async ValueTask CanvasRender(float time) {
        if (!HandleJsEvents) {
            return;
        }
        float deltaTime = time - _time;
        _time = time;
        await _render!.Render(deltaTime);
    }

    [JSInvokable]
    public void CanvasPointerMove(int x, int y) {
        if (!HandleJsEvents) {
            return;
        }
        _render!.OnPointerMove(x - LEFT_PANEL_WIDTH, y);
    }

    [JSInvokable]
    public void CanvasPointerDown(int button, bool shift, bool alt) {
        if (!HandleJsEvents) {
            return;
        }
        _render!.OnPointerDown(button, shift, alt);
    }

    [JSInvokable]
    public void CanvasPointerUp(int button, bool shift, bool alt) {
        if (!HandleJsEvents) {
            return;
        }
        _render!.OnPointerUp(button, shift, alt);
    }

    [JSInvokable]
    public void CanvasWheel(float deltaY, bool shift, bool alt) {
        if (!HandleJsEvents) {
            return;
        }
        _render!.OnWheel(deltaY, shift, alt);
    }

    private async Task DownloadResults() {
        var stream = GetDownloadStream();
        string filename = "TangentBaseCurve.json";
        var streamRef = new DotNetStreamReference(stream);
        await JsRuntime.InvokeAsync<object>("downloadFileFromStream", filename, streamRef);
    }

    private Stream GetDownloadStream(){
        var data = _render!.ObjectsContext.CurveEditor.CreateData();
        var json = TangentBasedCurveData.ToJson(data);
        return new MemoryStream(Encoding.UTF8.GetBytes(json));
    }

    public void Dispose(){
        JsRuntime.InvokeAsync<object>("canvasDispose", DotNetObjectReference.Create(this));
        _canvasContext = null;
        _render = null;
        _disposed = true;
    }
}
